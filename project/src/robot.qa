System robot

/*
 * *********************************************************
 * Messaggi & Eventi Ambiente
 * *********************************************************
 */
Dispatch environmentValid: environmentValid                         // X=valid|invalid
Event environmentOK: environmentOK
Event environmentNOTOK: environmentNOTOK

/*
 * *********************************************************
 * Messaggi & Eventi Robot Adapter
 * *********************************************************
 */
Event robotCmd: cmd(X)
Dispatch robotCmdPriority: cmd(X)

/*
 * *********************************************************
 * Messaggi & Eventi Mind
 * *********************************************************
 */
Dispatch cmdStop: cmdStop                                           // R-stopAtBag
Dispatch cmdGoHome: cmdGoHome                                       // R-backHome
Dispatch cmdExplore: cmdExplore                                     // R-explore
Dispatch cmdReachBomb: cmdReachBomb                                 // R-reachBag

Dispatch alert: alert                                               // R-alert

Dispatch robotState: state(X)                                       // R-consoleUpdate
Dispatch robotHome: robotHome
Dispatch proximityBag: proximityBag

Event temperature: temperature(X)

Dispatch handleBag: handleBag(X)                                    // R-stopAtBag & R-takePhoto
Dispatch bagStatus: isBomb(X)

Dispatch photoSend: photoSend(X)                                    // R-sendPhoto
Dispatch photoStore: photoStore(X)                                  // R-storePhoto

/** Contesto locale del robot. */
Context ctxRobot ip [ host="localhost" port=8079 ]

/** Attore che osserva l'ambiente e valuta la temperatura. */
QActor worldObserver context ctxRobot {

    Rules {
        evaluateTemp :- retract(temperature(X)), eval(lt, X, 25).   // R-TempOk
    }

    /**
     * Lo stato invalidEnvironment è lo stato nel quale l'attore si trova se la temperatura NON è OK.
     *
     * È anche lo stato iniziale dell'attore.
     *
     * Emette un evento che definisce l'ambiente come non OK.
     *
     * Attende per 60s un evento relativo alla temperatura per valutare se è OK.
     */
    State invalidEnvironment initial [
        emit environmentNOTOK: environmentNOTOK
    ] transition
        stopAfter 60000
        whenEvent temperature -> evaluateTemp                       // R-TempOk

    /**
     * Lo stato validEnvironment è lo stato nel quale l'attore si trova se la temperatura è OK.
     *
     * Emette un evento che definisce l'ambiente come OK.
     *
     * Attende per 60s un evento relativo alla temperatura per valutare se è OK.
     */
    State validEnvironment [
        emit environmentOK: environmentOK
    ] transition
        stopAfter 60000
        whenEvent temperature -> evaluateTemp                       // R-TempOk

    /**
     * Lo stato evaluateTemp è lo stato nel quale viene verificata la temperatura.
     *
     * In particolare:
     * - la temperatura viene aggiunta alle regole dell'attore
     * - se la temperatura è adeguata, si auto-invia un messaggio environmentValid
     *
     * Dopo 100ms passa allo stato invalid a meno che la temperatura non sia valid.
     */
    State evaluateTemp [                                            // R-TempOk
        onEvent temperature: temperature(X) -> addRule temperature(X);
        [ not !? evaluateTemp ] selfMsg environmentValid: environmentValid
    ] transition
        whenTime 100 -> invalidEnvironment
        whenMsg environmentValid -> validEnvironment
}

/** Attore che modella un robot. */
QActor robotadapter context ctxRobot {

    /** Stato iniziale TODO. */
    State init initial [

    ]

    /** Stato di lavoro TODO. */
    State doWork [

    ] transition
        stopAfter 60000
        whenMsg robotCmdPriority -> executeCommand,
        whenEvent robotCmd -> executeCommand

    /** Stato di interpretazione comandi TODO. */
    State executeCommand resumeLastPlan [
        onMsg robotCmdPriority: cmd(X) -> printCurrentMessage;
        onEvent robotCmd: cmd(X) -> printCurrentMessage
    ]
}

/** Attore che modella la mente, separata dal robot fisico. */
QActor mind context ctxRobot {

    /**
     * Stato iniziale del robot, nel quale l'ambiente viene valutato.
     *
     * Qualora non diventi valido entro 60s, il sistema si ferma.
     *
     * All'evento environmentOK passa allo stato home.
     */
    State invalidEnvironment initial [

    ] transition
        stopAfter 60000
        whenEvent environmentOK -> home

    /**
     * Lo stato home è lo stato del robot nel quale esso può iniziare ad operare.
     *
     * Una volta entrato in questo stato, invia un messaggio alla console.
     *
     * Attende per 60s di ricevere un comando o un evento:
     * - riguardante l'ambiente (non più OK)
     * - per iniziare l'esplorazione (discovery)
     * - per raggiungere la bomba (retriever)
     */
    State home [
        onMsg robotHome: robotHome ->
            forward console -m robotHome: robotHome
    ] transition
        stopAfter 60000
        whenEvent environmentNOTOK -> invalidEnvironment,
        whenMsg cmdExplore -> goToExploration,                      // R-explore
        whenMsg cmdReachBomb -> goToReachBomb                       // R-reachBag

    /*
     * ********************************************************* *
     * Exploration business logic                                *
     * ********************************************************* *
     */

    /**
     * Lo stato goToExploration è lo stato che precede l'inizio dell'esplorazione.
     *
     * La mind abilita il lampeggio del LED sul robot e inizia ad esplorare.
     */
    State goToExploration [
        emit robotCmd: cmd(blinkStart)                              // R-blinkLed (start)
    ] transition
        whenTime 1000 -> exploration

    /**
     * Lo stato exploration è lo stato più importante per la fase di discovery.
     *
     * Il robot invia alla console il proprio stato,
     * gestisce eventuali comandi o borse vicine
     * e continua ad esplorare.
     */
    State exploration [
        forward console -m robotState: state(X)                     // R-consoleUpdate
    ] transition
        whenTime 3000 -> exploration
        whenMsg cmdStop -> goToIdle,                                // R-stopExplore
        whenMsg proximityBag -> goToHandleBag

    /**
     * Lo stato goToHandleBag è lo stato che precede la fase di gestione della borsa.
     *
     * Il robot si ferma e scatta una foto, poi procede con la gestione della borsa.
     */
    State goToHandleBag [
        selfMsg handleBag: handleBag(halt);                         // R-stopAtBag
        selfMsg handleBag: handleBag(takePhoto)                     // R-takePhoto
    ] transition
        whenTime 10 -> handleBag

    /**
     * Lo stato handleBag è lo stato che permette di gestire concretamente una borsa.
     *
     * Gestisce i messaggi di halt e di scatto della foto, dopodiché attende istruzioni.
     */
    State handleBag [
        onMsg handleBag: handleBag(halt) -> {                       // R-stopAtBag
            emit robotCmd: cmd(h);
            emit robotCmd: cmd(blinkStop)
        };
        onMsg handleBag: handleBag(takePhoto) -> {
            printCurrentMessage;                                    // R-takePhoto
            forward console -m photoSend: photoSend(X)              // R-sendPhoto
        }
    ] transition
        whenTime 1000 -> handleBag
        whenMsg handleBag -> handleBag,
        whenMsg cmdGoHome -> returnHome,
        whenMsg cmdExplore -> goToExploration

    /**
     * Lo stato goToIdle è lo stato che precede lo stato di idle.
     *
     * In questo stato, il robot si ferma e spegne il LED.
     */
    State goToIdle [
        forward robotadapter -m robotCmdPriority: cmd(h);
        emit robotCmd: cmd(blinkStop)                               // R-blinkLed (stop)
    ] transition
        whenTime 1000 -> idle

    /**
     * Lo stato idle attende istruzioni per tornare ad esplorare o tornare a casa.
     */
    State idle [

    ] transition
        whenTime 3000 -> idle
        whenMsg cmdExplore -> exploration,                          // R-continueExplore
        whenMsg cmdGoHome -> returnHome                             // R-backHome

    /**
     * Lo stato returnHome è lo stato in cui il robot torna a casa.
     *
     * Lo stato si ripete finché non è a casa, poi passa ad home.
     */
    State returnHome [
        printCurrentMessage // TODO
    ] transition
        whenTime 3000 -> returnHome
        whenMsg robotHome -> home

    /*
     * ********************************************************* *
     * Defuse business logic                                     *
     * ********************************************************* *
     */

    /**
     * Lo stato goToReachBomb è lo stato che precede lo stato di viaggio verso la bomba.
     */
    State goToReachBomb [

    ] transition
        whenTime 1000 -> reachBomb

    /**
     * Lo stato reachBomb è lo stato in cui il robot viaggia verso la bomba.
     *
     * Lo stato si ripete finché non raggiunge la bomba e torna indietro, poi passa ad home.
     */
    State reachBomb [

    ] transition
        whenTime 3000 -> reachBomb
        whenMsg robotHome -> home
}

/** Attore console. */
QActor console context ctxRobot {

    /** Stato iniziale della console. */
    State init initial [

    ] transition
        whenTime 3000 -> doWork

    /**
     * Stato principale della console.
     *
     * Per un attesa massima di 60s,
     * attende messaggi dal robot e li gestisce.
     */
    State doWork [

    ] transition
        stopAfter 60000
        whenMsg robotState -> updateView,                           // R-consoleUpdate
        whenMsg photoSend -> handlePhoto
        finally repeatPlan

    /**
     * Lo stato handlePhoto gestisce la ricezione di una foto dal robot.
     *
     * Attende un messaggio di bagStatus per gestirlo.
     */
    State handlePhoto [
        onMsg photoSend: photoSend(X) -> printCurrentMessage
    ] transition
        whenTime 3000 -> handlePhoto
        whenMsg bagStatus -> handleBagStatus

    /**
     * Lo stato handleBagStatus permette di gestire se la borsa è una bomba o no.
     *
     * Se lo è, memorizza la foto, ordina al robot di tornare e segnala un alert.
     * Se non lo è, ordina al robot di continuare l'esplorazione.
     */
    State handleBagStatus [
        onMsg bagStatus: isBomb(true) -> {
            selfMsg photoStore: photoStore(X);                      // R-storePhoto
            forward mind -m cmdGoHome: cmdGoHome;                   // R-backHomeSinceBomb
            selfMsg alert: alert                                    // R-alert
        };
        onMsg bagStatus: isBomb(false) ->
            forward mind -m cmdExplore: cmdExplore                  // R-continueExploreAfterPhoto
    ] transition
        whenTime 3000 -> doWork
        whenMsg photoStore: photoStore(x) do printCurrentMessage,
        whenMsg alert -> handleAlert

    /**
     * Lo stato handleAlert permette di gestire uno stato di allerta.
     *
     * Aspetta che il robot sia tornato poi lo manda a raccogliere la bomba.
     */
    State handleAlert [

    ] transition
        whenTime 3000 -> handleAlert
        whenMsg robotHome: robotHome
            do forward mind -m cmdReachBomb: cmdReachBomb           // R-whaitForHome & R-reachBag

    /**
     * Lo stato updateView permette di gestire gli aggiornamenti di stato della vista.
     *
     * Una volta fatto, riprende lo stato precedente.
     */
    State updateView resumeLastPlan [
        onMsg robotState: state(X) -> printCurrentMessage
    ]
}
